/**
 * @fileoverview Firestore Security Rules for AkiliPesa application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data
 * while allowing public read access to certain collections like 'posts' and 'products'.
 *
 * Data Structure:
 * - User-specific data (profiles, clones, agents) is nested under /users/{userId}.
 * - Public data (posts, products) resides in top-level collections.
 *
 * Key Security Decisions:
 * - Listing users is disallowed.
 * - Admin settings are read-only and only accessible to authenticated users.
 * - Ambiguous relationships default to owner-only access.
 * - All write operations require authentication.
 *
 * Denormalization for Authorization:
 *  The rules rely on denormalization, such as including `ownerId` or `authorId` fields within documents
 *  to avoid costly `get()` operations in the security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Root-level authentication check. All users must be signed in.
     * @path /
     * @allow (get, list, create, update, delete) if isSignedIn()
     * @deny (get, list, create, update, delete) if false
     * @principle Requires all requests to be authenticated.
     */
    match /{document=**} {
      allow read, write: if isSignedIn();
    }

    /**
     * @description Enforces access control for user profiles.
     * @path /users/{userId}
     * @allow (get) Any authenticated user can read a profile.
     * @allow (list) Listing all users is disallowed.
     * @allow (create) A user can create their own profile, ensuring the UID matches the document ID.
     * @allow (update) A user can update their own profile.
     * @allow (delete) A user can delete their own profile.
     * @deny (get) if false
     * @deny (list) Listing all users is disallowed for privacy reasons.
     * @deny (create) if request.auth.uid != request.resource.data.uid;
     * @deny (update) if !isExistingOwner(userId);
     * @deny (delete) if !isExistingOwner(userId);
     * @principle Enforces document ownership for writes and restricts listing.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && isSelfCreation(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user-specific digital clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (get, list) The owner can read their own clones.
     * @allow (create) The owner can create clones under their user ID.
     * @allow (update, delete) The owner can update and delete their own clones.
     * @deny (get, list) if !isOwner(userId);
     * @deny (create) if !isOwner(userId);
     * @deny (update) if !isExistingOwner(userId);
     * @deny (delete) if !isExistingOwner(userId);
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/clones/{cloneId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) && isOwner(userId);
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

    /**
     * @description Enforces access control for user-specific AI agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (get, list) The owner can read their own agents.
     * @allow (create) The owner can create agents under their user ID.
     * @allow (update, delete) The owner can update and delete their own agents.
     * @deny (get, list) if !isOwner(userId);
     * @deny (create) if !isOwner(userId);
     * @deny (update) if !isExistingOwner(userId);
     * @deny (delete) if !isExistingOwner(userId);
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/agents/{agentId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) && isOwner(userId);
      allow delete: if isExistingOwner(userId) && isOwner(userId);
    }

   /**
     * @description Enforces access control for posts. Public read, owner-only writes.
     * @path /posts/{postId}
     * @allow (get, list) All users can read posts.
     * @allow (create) Only the post author can create a post, and the authorId must match the authenticated user.
     * @allow (update, delete) Only the post author can update or delete their own posts.
     * @deny (get, list) if false
     * @deny (create) if request.resource.data.authorId != request.auth.uid;
     * @deny (update) if !isExistingOwner(resource.data.authorId);
     * @deny (delete) if !isExistingOwner(resource.data.authorId);
     * @principle Public read access with owner-only writes, enforcing ownership on create, update, and delete.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Enforces access control for products. Public read, owner-only writes.
     * @path /products/{productId}
     * @allow (get, list) All users can read products.
     * @allow (create) Only the product owner can create a product, and the ownerId must match the authenticated user.
     * @allow (update, delete) Only the product owner can update or delete their own products.
     * @deny (get, list) if false
     * @deny (create) if request.resource.data.ownerId != request.auth.uid;
     * @deny (update) if !isExistingOwner(resource.data.ownerId);
     * @deny (delete) if !isExistingOwner(resource.data.ownerId);
     * @principle Public read access with owner-only writes, enforcing ownership on create, update, and delete.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Enforces access control for orders.
     * @path /orders/{orderId}
     * @allow (get, list) Any authenticated user can read orders.
     * @allow (create) Any authenticated user can create an order.
     * @allow (update, delete) No one is allowed to update or delete orders.
     * @deny (get, list) if request.auth == null;
     * @deny (create) if request.auth == null;
     * @deny (update, delete) if true;
     * @principle Authenticated users can create and read orders; updates/deletes are forbidden.
     */
    match /orders/{orderId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

   /**
     * @description Enforces access control for payments.
     * @path /payments/{paymentId}
     * @allow (get, list) Any authenticated user can read payments.
     * @allow (create) Any authenticated user can create a payment.
     * @allow (update, delete) No one is allowed to update or delete payments.
     * @deny (get, list) if request.auth == null;
     * @deny (create) if request.auth == null;
     * @deny (update, delete) if true;
     * @principle Authenticated users can create and read payments; updates/deletes are forbidden.
     */
    match /payments/{paymentId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    /**
     * @description Enforces access control for subscription plans.
     * @path /plans/{planId}
     * @allow (get, list) All users can read available plans.
     * @allow (create, update, delete) No one is allowed to create, update, or delete plans via client.
     * @deny (get, list) if false
     * @deny (create, update, delete) if true;
     * @principle Public read access, no client-side writes.
     */
    match /plans/{planId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Enforces access control for call sessions.
     * @path /calls/{callId}
     * @allow (get, list) Any authenticated user can read call sessions.
     * @allow (create) Any authenticated user can create a call session.
     * @allow (update, delete) No one is allowed to update or delete calls.
     * @deny (get, list) if request.auth == null;
     * @deny (create) if request.auth == null;
     * @deny (update, delete) if true;
     * @principle Authenticated users can create and read calls; updates/deletes are forbidden.
     */
    match /calls/{callId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

   /**
     * @description Enforces access control for transactions.
     * @path /transactions/{txId}
     * @allow (get, list) Any authenticated user can read transactions if they own them.
     * Admin email "blagridigital@gmail.com" can also read all transactions.
     * @allow (create) Only the transaction owner can create.
     * @allow (update, delete) No one can update or delete transactions.
     * @deny (get, list) if request.auth == null || (request.auth.token.email != "blagridigital@gmail.com" && resource.data.uid != request.auth.uid);
     * @deny (create) if request.auth == null || request.resource.data.uid != request.auth.uid;
     * @deny (update, delete) if true;
     * @principle Owner can read own transactions, and create transactions with matching UID.
     */
    match /transactions/{txId} {
        allow get, list: if request.auth != null &&
        (request.auth.token.email == "blagridigital@gmail.com" ||
        resource.data.uid == request.auth.uid);
        allow create: if request.auth != null &&
        request.resource.data.uid == request.auth.uid;
        allow update, delete: if false;
    }

    /**
     * @description Enforces access control for admin settings.
     * @path /adminSettings/{settingId}
     * @allow (get, list) Any authenticated user can read admin settings.
     * @allow (create, update, delete) No one is allowed to create, update, or delete admin settings via client.
     * @deny (get, list) if request.auth == null;
     * @deny (create, update, delete) if true;
     * @principle Public read access, no client-side writes.
     */
    match /adminSettings/{settingId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }

    /**
     * @description Enforces access control for admin agents.
     * @path /adminAgents/{agentId}
     * @allow (get, list) Any authenticated user can read admin agents.
     * @allow (create, update, delete) No one is allowed to create, update, or delete admin agents via client.
     * @deny (get, list) if request.auth == null;
     * @deny (create, update, delete) if true;
     * @principle Public read access, no client-side writes.
     */
    match /adminAgents/{agentId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }

    /**
     * @description Helper function to check if a user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Helper function to check if the requesting user is the owner of the resource.
     * @param {string} userId The user ID to compare against the request's authentication UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Helper function to check if the requesting user is creating their own root user document.
     * @param {string} userId The user ID to compare against the request's authentication UID.
     * @return {boolean} True if the user is creating their own root document, false otherwise.
     */
    function isSelfCreation(userId) {
        return request.auth.uid == userId && request.auth.uid == request.resource.data.uid;
    }

   /**
     * @description Helper function to check if the requesting user is the owner of an existing resource.
     * @param {string} userId The user ID to compare against the resource's data.
     * @return {boolean} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}