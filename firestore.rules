/**
 * @file Firebase Security Rules for AkiliPesa - Phase 10: Buyer Reputation & Community Trust Score.
 *
 * @corePhilosophy This ruleset enforces a combination of user-based ownership for user profiles and their associated data,
 *                 public read access for certain collections (e.g., products), and admin-restricted access for sensitive settings.
 *                 It also adds rules for buyer trust scores, allowing users to read their own trust score and admins to manage all trust data.
 *
 * @dataStructure
 * - /users/{userId}: User profile data, accessible only to the user and admins.
 * - /posts/{postId}: Public posts, readable by everyone but writable only by the author.
 * - /users/{userId}/clones/{cloneId}: User-owned digital clones, accessible only to the user.
 * - /users/{userId}/agents/{agentId}: User-owned AI agents, accessible only to the user.
 * - /products/{productId}: Public products, readable by everyone but writable only by the owner.
 * - /orders/{orderId}: Orders, accessible to the buyer, seller, and admins.
 * - /payments/{paymentId}: Payments data, accessible to seller and admins.
 * - /plans/{planId}: Public subscription plans, readable by everyone.
 * - /calls/{callId}: Call session data, accessible to the participants.
 * - /transactions/{txId}: Transaction history, accessible only to the user and admins.
 * - /adminSettings/{settingId}: Admin settings, accessible only to admins.
 * - /adminAgents/{agentId}: Admin-created AI agents, accessible only to admins.
 * - /buyerTrust/{buyerId}: Buyer trust score data, readable by the user and writable by admins.
 * - /behaviorLogs/{id}: Behavior logs, readable by admins and creatable by anyone.
 * - /buyerHistory/{id}: Buyer history, readable by admins.
 *
 * @keySecurityDecisions
 * - User data is strictly controlled, with only the user having access to their profile and associated data.
 * - Public content (posts, products, plans) is readable by everyone, but write access is restricted to owners or admins.
 * - Admin-only collections (adminSettings, adminAgents) are secured to prevent unauthorized access.
 * - Listing operations are generally allowed for user-owned subcollections, but not for top-level collections unless explicitly intended to be public.
 * - The rules use denormalization where needed to avoid costly `get()` calls and simplify authorization logic.
 *
 * @denormalizationForAuthorization
 * - Buyer trust scores are stored in a separate collection (`/buyerTrust/{buyerId}`), with access controlled based on the `buyerId`.
 *
 * @structuralSegregation Publicly readable data is separated from private user data to simplify rules and improve performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read their own profile data, and allows creating their profile.
     * @path /users/{userId}
     * @allow (get) User with matching {userId} can read.
     * @allow (create) User can create their own profile if the uid matches the document ID.
     * @deny (get) User trying to read another user's profile.
     * @deny (create) User trying to create a profile with a mismatched uid.
     * @deny (update) User trying to update another user's profile.
     * @deny (delete) User trying to delete another user's profile.
     * @principle Enforces user-ownership for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows public read access to posts and enforces owner-only writes based on the authorId field.
     * @path /posts/{postId}
     * @allow (get) Any user can read any post.
     * @allow (list) Any user can list posts.
     * @allow (create) User can create a post if the authorId matches their auth UID.
     * @deny (create) User trying to create a post with a mismatched authorId.
     * @deny (update) User trying to update a post they don't own.
     * @deny (delete) User trying to delete a post they don't own.
     * @principle Enforces owner-only writes for posts while allowing public reads.
     */
    match /posts/{postId} {
      function isOwner(authorId) {
        return request.auth != null && request.auth.uid == authorId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if request.auth != null && isOwner(resource.data.authorId) && resource != null;
      allow delete: if request.auth != null && isOwner(resource.data.authorId) && resource != null;
    }

    /**
     * @description Allows a user to manage their own clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (get) User with matching {userId} can read their clone.
     * @allow (list) User with matching {userId} can list their clones.
     * @allow (create) User can create a clone under their own user ID.
     * @deny (get) User trying to read another user's clone.
     * @deny (create) User trying to create a clone under another user's ID.
     * @deny (update) User trying to update another user's clone.
     * @deny (delete) User trying to delete another user's clone.
     * @principle Enforces user-ownership for digital clones.
     */
    match /users/{userId}/clones/{cloneId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && resource != null;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows a user to manage their own agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (get) User with matching {userId} can read their agent.
     * @allow (list) User with matching {userId} can list their agents.
     * @allow (create) User can create an agent under their own user ID.
     * @deny (get) User trying to read another user's agent.
     * @deny (create) User trying to create an agent under another user's ID.
     * @deny (update) User trying to update another user's agent.
     * @deny (delete) User trying to delete another user's agent.
     * @principle Enforces user-ownership for AI agents.
     */
    match /users/{userId}/agents/{agentId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && resource != null;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows public read access to products and enforces owner-only writes based on the ownerId field.
     * @path /products/{productId}
     * @allow (get) Any user can read any product.
     * @allow (list) Any user can list products.
     * @allow (create) User can create a product if the ownerId matches their auth UID.
     * @deny (create) User trying to create a product with a mismatched ownerId.
     * @deny (update) User trying to update a product they don't own.
     * @deny (delete) User trying to delete a product they don't own.
     * @principle Enforces owner-only writes for products while allowing public reads.
     */
    match /products/{productId} {
      function isOwner(ownerId) {
        return request.auth != null && request.auth.uid == ownerId;
      }

      allow get: if true;
      allow list: if true;
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      allow update: if request.auth != null && isOwner(resource.data.ownerId) && resource != null;
      allow delete: if request.auth != null && isOwner(resource.data.ownerId) && resource != null;
    }

    /**
     * @description Allows access to orders based on buyerId, sellerId or admin role.
     * @path /orders/{orderId}
     * @allow (get) Buyer, seller, or admin can read an order.
     * @allow (list) Buyer, seller, or admin can list orders.
     * @deny (create) User trying to create an order for another user.
     * @deny (update) User trying to update an order they are not associated with.
     * @deny (delete) User trying to delete an order they are not associated with.
     * @principle Allows order access to buyer, seller and admin.
     */
    match /orders/{orderId} {
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }
      function isBuyerOrSeller(buyerId, sellerId) {
        return request.auth != null && (request.auth.uid == buyerId || request.auth.uid == sellerId);
      }

      allow get: if isBuyerOrSeller(resource.data.buyerId, resource.data.sellerId) || isAdmin();
      allow list: if isAdmin();
      allow create: if request.auth != null && request.resource.data.buyerId == request.auth.uid;
      allow update: if (isBuyerOrSeller(resource.data.buyerId, resource.data.sellerId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Allows access to payments data based on sellerId or admin role.
     * @path /payments/{paymentId}
     * @allow (get) Seller or admin can read a payment.
     * @allow (list) Admin can list payments.
     * @deny (create) User trying to create a payment for another user.
     * @deny (update) User trying to update a payment they are not associated with.
     * @deny (delete) User trying to delete a payment they are not associated with.
     * @principle Allows payment access to seller and admin.
     */
    match /payments/{paymentId} {
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }
      function isSeller(sellerId) {
        return request.auth != null && request.auth.uid == sellerId;
      }

      allow get: if isSeller(resource.data.sellerId) || isAdmin();
      allow list: if isAdmin();
      allow create: if request.auth != null && request.resource.data.sellerId == request.auth.uid;
      allow update: if (isSeller(resource.data.sellerId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Allows public read access to plans.
     * @path /plans/{planId}
     * @allow (get) Any user can read any plan.
     * @allow (list) Any user can list plans.
     * @deny (create) No user can create a plan. Only admins can create plans.
     * @deny (update) No user can update a plan. Only admins can update plans.
     * @deny (delete) No user can delete a plan. Only admins can delete plans.
     * @principle Allows public reads of subscription plans.
     */
    match /plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows access to calls data based on callerId, agentId, or admin role.
     * @path /calls/{callId}
     * @allow (get) Caller, agent or admin can read a call.
     * @allow (list) Admin can list calls.
     * @deny (create) User trying to create a call for another user.
     * @deny (update) User trying to update a call they are not associated with.
     * @deny (delete) User trying to delete a call they are not associated with.
     * @principle Allows call access to caller, agent and admin.
     */
    match /calls/{callId} {
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }
      function isParticipant(callerId, agentId) {
        return request.auth != null && (request.auth.uid == callerId || request.auth.uid == agentId);
      }

      allow get: if isParticipant(resource.data.callerId, resource.data.agentId) || isAdmin();
      allow list: if isAdmin();
      allow create: if request.auth != null && (request.resource.data.callerId == request.auth.uid || request.resource.data.agentId == request.auth.uid);
      allow update: if (isParticipant(resource.data.callerId, resource.data.agentId) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Allows a user to read their own transactions.
     * @path /transactions/{txId}
     * @allow (get) User with matching uid can read their transactions.
     * @allow (list) User with matching uid can list their transactions.
     * @deny (create) User trying to create a transaction for another user.
     * @deny (update) User trying to update another user's transaction.
     * @deny (delete) User trying to delete another user's transaction.
     * @principle Enforces user-ownership for transactions.
     */
    match /transactions/{txId} {
      function isOwner(uid) {
        return request.auth != null && request.auth.uid == uid;
      }
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }

      allow get: if isOwner(resource.data.uid) || isAdmin();
      allow list: if isOwner(resource.data.uid) || isAdmin();
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow update: if (isOwner(resource.data.uid) || isAdmin()) && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Restricts access to admin settings to only admins.
     * @path /adminSettings/{settingId}
     * @allow (get) Admin can read settings.
     * @allow (list) No one can list admin settings.
     * @deny (create) No user can create admin settings.
     * @deny (update) No user can update admin settings.
     * @deny (delete) No user can delete admin settings.
     * @principle Restricts access to admin settings.
     */
    match /adminSettings/{settingId} {
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }

      allow get: if isAdmin();
      allow list: if false;
      allow create: if false;
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Restricts access to admin agents to only admins.
     * @path /adminAgents/{agentId}
     * @allow (get) Admin can read agents.
     * @allow (list) Admin can list admin agents.
     * @deny (create) No user can create admin agents.
     * @deny (update) No user can update admin agents.
     * @deny (delete) No user can delete admin agents.
     * @principle Restricts access to admin agents.
     */
    match /adminAgents/{agentId} {
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }

      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Allows users to read their own buyer trust score and admins to manage all trust data.
     * @path /buyerTrust/{buyerId}
     * @allow (get) User can read their own trust score, and admin can read all trust scores.
     * @allow (list) Admin can list all trust scores.
     * @allow (create) Admin can create trust scores.
     * @deny (create) Users cannot create trust scores.
     * @deny (update) Users cannot update trust scores.
     * @deny (delete) Users cannot delete trust scores.
     * @principle Enforces user-ownership for read access and admin-only write access to buyer trust scores.
     */
    match /buyerTrust/{buyerId} {
      function isOwner(buyerId) {
        return request.auth != null && request.auth.uid == buyerId;
      }

      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }

      allow get: if isOwner(buyerId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Allows anyone to create behavior logs, but only admins can read them.
     * @path /behaviorLogs/{id}
     * @allow (create) Any authenticated user can create a behavior log.
     * @allow (get) Only admin can read behavior logs.
     * @allow (list) Only admin can list behavior logs.
     * @deny (update) No one can update behavior logs.
     * @deny (delete) No one can delete behavior logs.
     * @principle Allows public creation and admin-only read access to behavior logs.
     */
    match /behaviorLogs/{id} {
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }

      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if request.auth != null;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows only admins to read buyer history data.
     * @path /buyerHistory/{id}
     * @allow (get) Only admin can read buyer history.
     * @allow (list) Only admin can list buyer history.
     * @deny (create) No one can create buyer history through rules (only backend).
     * @deny (update) No one can update buyer history.
     * @deny (delete) No one can delete buyer history.
     * @principle Restricts access to buyer history to admins.
     */
    match /buyerHistory/{id} {
      function isAdmin() {
        return request.auth != null && request.auth.token.email == "blagridigital@gmail.com";
      }

      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}