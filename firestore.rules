/**
 * @file Firestore Security Rules for AkiliPesa AI Platform
 *
 * @corePhilosophy This ruleset enforces a hybrid security model, combining user-ownership for personal data with public read access for certain collections.
 *  It prioritizes secure write access while allowing flexible data shapes during the prototyping phase.
 *
 * @dataStructure
 *  - `/users/{userId}`: Stores user profiles.  The `userId` is used for owner-based access control.
 *  - `/users/{userId}/clones/{cloneId}`: Stores digital clones owned by the user.
 *  - `/users/{userId}/agents/{agentId}`: Stores AI agents owned by the user.
 *  - `/posts/{postId}`: Stores public posts. Access control uses an `authorId` field within each document.
 *  - `/products/{productId}`: Stores public products. Access control uses an `ownerId` field within each document.
 *  - `/transactions/{txId}`: Stores transaction records, with access control based on the `uid` field within each document.
 *  - `/wallets/{walletId}`: Stores wallet information, where `walletId` is expected to match the user ID.
 *  - `/orders/{orderId}`, `/payments/{paymentId}`, `/plans/{planId}`, `/calls/{callId}`: Publicly readable collections with restricted write access.
 *  - `/followers/{followId}`, `/notifications/{notifId}`: Collections for managing followers and notifications, with owner-based access.
 *  - `/adminSettings/{settingId}`, `/adminAgents/{agentId}`: Publicly readable collections with no write access for regular users.
 *
 * @keySecurityDecisions
 *  - Public Read Access: Collections like `/posts`, `/products`, `/orders`, `/payments`, `/plans`, `/calls`, `/adminSettings`, and `/adminAgents` allow public read access (`get`, `list`). This is suitable for data intended for general consumption.
 *  - Ownership Model: The ruleset relies heavily on the "ownership" model, where a user can only modify or delete data they own. This is enforced through the `isOwner()` helper function, which compares `request.auth.uid` to a designated owner field within the document (e.g., `authorId`, `ownerId`, `uid`).
 *  - Data Denormalization: The rules assume that key authorization data (like `authorId` or `ownerId`) is denormalized directly onto the documents. This is crucial for efficient security rules that avoid costly `get()` operations.
 *  - List Restrictions: For the `/transactions` and `/notifications` collections, the rules restrict `list` operations to only those queries where the `uid` field matches the authenticated user's UID, thus ensuring that users can only see their own data.
 *  - Write Restrictions: Write operations are generally restricted to authenticated users. The rules ensure that only the owner or creator of a resource can modify or delete it, except in cases where write operations are explicitly denied (e.g., `/adminSettings`, `/adminAgents`).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile access. Allows public read access, but restricts write access to the owner.
     * @path /users/{userId}
     * @allow (get, list): Anyone can read user profiles.
     * @allow (create, update, delete): Authenticated user with `request.auth.uid == userId`.
     * @deny (create, update, delete): Authenticated user with `request.auth.uid != userId`.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }

      allow get, list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user-specific clones. Only the owner can read and write.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (get, list, create, update, delete): Authenticated user with `request.auth.uid == userId`.
     * @deny (get, list, create, update, delete): Authenticated user with `request.auth.uid != userId`.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/clones/{cloneId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }
      allow get, list, create, update, delete: if isOwner(userId);
    }

    /**
     * @description Manages user-specific AI agents. Only the owner can read and write.
     * @path /users/{userId}/agents/{agentId}
     * @allow (get, list, create, update, delete): Authenticated user with `request.auth.uid == userId`.
     * @deny (get, list, create, update, delete): Authenticated user with `request.auth.uid != userId`.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/agents/{agentId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource.data != null;
      }
      allow get, list, create, update, delete: if isOwner(userId);
    }

    /**
     * @description Manages public posts. Allows public read access, but restricts write access to the post's author.
     * @path /posts/{postId}
     * @allow (get, list): Anyone can read posts.
     * @allow (create): Authenticated user creating a post with `request.resource.data.authorId == request.auth.uid`.
     * @allow (update, delete): Authenticated user who is the author of the post (`resource.data.authorId == request.auth.uid`).
     * @deny (create): Authenticated user creating a post with `request.resource.data.authorId != request.auth.uid`.
     * @deny (update, delete): Authenticated user who is not the author of the post.
     * @principle Enforces document ownership for writes on a publicly readable collection.
     */
    match /posts/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isCreatingOwner() {
        return isSignedIn() && request.resource.data.authorId == request.auth.uid;
      }
      function isOwner() {
        return isSignedIn() && resource.data.authorId == request.auth.uid;
      }
       function isExistingOwner() {
        return isOwner() && resource.data != null;
      }

      allow get, list: if true;
      allow create: if isCreatingOwner();
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Manages public products. Allows public read access, but restricts write access to the product's owner.
     * @path /products/{productId}
     * @allow (get, list): Anyone can read products.
     * @allow (create): Authenticated user creating a product with `request.resource.data.ownerId == request.auth.uid`.
     * @allow (update, delete): Authenticated user who is the owner of the product (`resource.data.ownerId == request.auth.uid`).
     * @deny (create): Authenticated user creating a product with `request.resource.data.ownerId != request.auth.uid`.
     * @deny (update, delete): Authenticated user who is not the owner of the product.
     * @principle Enforces document ownership for writes on a publicly readable collection.
     */
    match /products/{productId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isCreatingOwner() {
        return isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      }
      function isOwner() {
        return isSignedIn() && resource.data.ownerId == request.auth.uid;
      }
       function isExistingOwner() {
        return isOwner() && resource.data != null;
      }

      allow get, list: if true;
      allow create: if isCreatingOwner();
      allow update: if isExistingOwner();
      allow delete: if isExistingOwner();
    }

    /**
     * @description Manages user transactions. Restricts read and write access to the user associated with the transaction.
     * @path /transactions/{txId}
     * @allow (get): Authenticated user accessing their own transaction (`resource.data.uid == request.auth.uid`).
     * @allow (list): Authenticated user listing their own transactions via a query where `uid == request.auth.uid`.
     * @allow (create): Authenticated user creating a transaction with `request.resource.data.uid == request.auth.uid`.
     * @deny (update, delete): No one can update or delete transactions.
     */
    match /transactions/{txId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner() {
          return isSignedIn() && request.resource.data.uid == request.auth.uid;
      }

      allow get: if isSignedIn() && resource.data.uid == request.auth.uid;
      allow list: if isSignedIn() && request.query.get("uid") == request.auth.uid;
      allow create: if isOwner();
      allow update, delete: if false;
    }

    /**
     * @description Manages user wallets. Restricts read and write access to the wallet owner.
     *  It is assumed that the `walletId` matches the user ID.
     * @path /wallets/{walletId}
     * @allow (get, list, create, update, delete): Authenticated user where `request.auth.uid == walletId`.
     * @deny (get, list, create, update, delete): Authenticated user where `request.auth.uid != walletId`.
     * @principle Enforces document ownership based on the wallet ID.
     */
    match /wallets/{walletId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(walletId) {
        return isSignedIn() && request.auth.uid == walletId;
      }
       function isExistingOwner(walletId) {
        return isOwner(walletId) && resource.data != null;
      }
      allow get, list, create, update, delete: if isOwner(walletId);
    }

    /**
     * @description Manages orders. Allows public read access, but restricts write access to authenticated users.
     * @path /orders/{orderId}
     * @allow (get, list): Anyone can read orders.
     * @allow (create): Authenticated users can create orders.
     * @deny (update, delete): No one can update or delete orders.
     */
    match /orders/{orderId} {
       function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    /**
     * @description Manages payments. Allows public read access, but restricts write access to authenticated users.
     * @path /payments/{paymentId}
     * @allow (get, list): Anyone can read payments.
     * @allow (create): Authenticated users can create payments.
     * @deny (update, delete): No one can update or delete payments.
     */
    match /payments/{paymentId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    /**
     * @description Manages plans. Allows public read access, but restricts write access to authenticated users.
     * @path /plans/{planId}
     * @allow (get, list): Anyone can read plans.
     * @allow (create): Authenticated users can create plans.
     * @deny (update, delete): No one can update or delete plans.
     */
    match /plans/{planId} {
       function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    /**
     * @description Manages calls. Allows public read access, but restricts write access to authenticated users.
     * @path /calls/{callId}
     * @allow (get, list): Anyone can read calls.
     * @allow (create): Authenticated users can create calls.
     * @deny (update, delete): No one can update or delete calls.
     */
    match /calls/{callId} {
       function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if false;
    }

    /**
     * @description Manages followers. Allows read and write access to authenticated users.
     * @path /followers/{followId}
     * @allow (get, list): Authenticated user can read followers.
     * @allow (create, delete): Authenticated user can create and delete followers.
     */
    match /followers/{followId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create, delete: if isSignedIn();
      allow update: if false;
    }

    /**
     * @description Manages notifications. Restricts read and write access to the user associated with the notification.
     * @path /notifications/{notifId}
     * @allow (get, list): Authenticated user accessing their own notifications via a query where `uid == request.auth.uid`.
     * @allow (create): Authenticated user creating a notification with `request.resource.data.uid == request.auth.uid`.
     * @allow (update): Authenticated user updating their own notification (`resource.data.uid == request.auth.uid`).
     * @deny (delete): No one can delete notifications.
     */
    match /notifications/{notifId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner() {
          return isSignedIn() && request.resource.data.uid == request.auth.uid;
      }
      allow get, list: if isSignedIn() && request.query.get("uid") == request.auth.uid;
      allow create: if isOwner();
      allow update: if isOwner();
      allow delete: if false;
    }

    /**
     * @description Manages admin settings. Allows public read access, but denies write access.
     * @path /adminSettings/{settingId}
     * @allow (get, list): Anyone can read admin settings.
     * @deny (create, update, delete): No one can create, update, or delete admin settings.
     */
    match /adminSettings/{settingId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Manages admin agents. Allows public read access, but denies write access.
     * @path /adminAgents/{agentId}
     * @allow (get, list): Anyone can read admin agents.
     * @deny (create, update, delete): No one can create, update, or delete admin agents.
     */
    match /adminAgents/{agentId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }
  }
}