/**
 * @file Firebase Security Rules for AkiliPesa - Prototyping Mode
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model where users can only manage their own data,
 * with public read access for certain collections like 'posts' and 'products'. It avoids complex data validation
 * in favor of rapid prototyping but focuses on securing access based on user identity.
 *
 * @data_structure
 * - User-specific data is nested under `/users/{userId}`.
 * - Publicly readable data (e.g., posts, products) resides in top-level collections.
 * - Some documents contain denormalized data (e.g., userId on posts) to simplify authorization.
 *
 * @key_security_decisions
 * - User listing is disallowed to prevent unauthorized data scraping.
 * - Read-only collections like 'plans' are publicly readable.
 * - Ambiguous relationships default to owner-only access.
 *
 * @denormalization_for_authorization
 * - Posts include an `authorId` field for ownership checks.
 * - Products include an `ownerId` field for ownership checks.
 * - BuyerTrust includes a `buyerId` field for ownership checks.
 *
 * @structural_segregation Private user data is stored in `/users/{userId}/...` subcollections,
 * while public data is stored in top-level collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by an authenticated user.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided user ID.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     * @param {string} userId The user ID to compare against the document's owner ID.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Defines a consistent way to validate `create` requests for owner-only documents.
     * @param {string} ownerIdField The name of the field in the document that stores the owner's user ID.
     * @return {boolean} True if the user ID matches the authenticated user and the resource data is valid, false otherwise.
     */
    function isValidOwnerCreateRequest(ownerIdField) {
        return request.resource.data[ownerIdField] == request.auth.uid;
    }

    /**
     * @description Defines a consistent way to validate `update` requests for owner-only documents.
     * @param {string} ownerIdField The name of the field in the document that stores the owner's user ID.
     * @return {boolean} True if the user ID matches the authenticated user and the resource data is valid, false otherwise.
     */
    function isValidOwnerUpdateRequest(ownerIdField) {
        return request.resource.data[ownerIdField] == resource.data[ownerIdField];
    }

    /**
     * @description Secures the /users/{userId} path.
     * @path /users/{userId}
     * @allow (create) User with UID 'testUID' can create their profile if request.auth.uid == 'testUID'.
     * @allow (get, update, delete) User with UID 'testUID' can read/update/delete their profile if request.auth.uid == 'testUID'.
     * @deny (create) User with UID 'otherUID' cannot create a profile for 'testUID'.
     * @deny (get, update, delete) User with UID 'otherUID' cannot read/update/delete the profile of 'testUID'.
     * @principle Enforces user-ownership for user profiles.
     */
    match /users/{userId} {
      // Only the user can create their own profile.
      allow create: if isOwner(userId) && isValidOwnerCreateRequest('uid');
      // Only the user can read their own profile.
      allow get: if isOwner(userId);
      // Only the user can list their own profile -- explicitly deny, listing users is not allowed
      allow list: if false;
      // Only the user can update their own profile, but the userId must not change.
      allow update: if isExistingOwner(userId) && isValidOwnerUpdateRequest('uid');
      // Only the user can delete their own profile.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures the /posts/{postId} path. Allows public read, but restricts writes to the post author.
     * @path /posts/{postId}
     * @allow (get, list) Any user can read any post.
     * @allow (create) User with UID 'testUID' can create a post with authorId 'testUID'.
     * @allow (update, delete) User with UID 'testUID' can update/delete their post if resource.data.authorId == 'testUID'.
     * @deny (create) User with UID 'otherUID' cannot create a post with authorId 'testUID'.
     * @deny (update, delete) User with UID 'otherUID' cannot update/delete the post of 'testUID'.
     * @principle Allows public read access, but enforces document ownership for writes.
     */
    match /posts/{postId} {
      // Anyone can read posts.
      allow get, list: if true;
      // Only the author can create a post.
      allow create: if isSignedIn() && isValidOwnerCreateRequest('authorId');
      // Only the author can update or delete their own post.
      allow update: if isExistingOwner(resource.data.authorId) && isValidOwnerUpdateRequest('authorId');
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Secures the /users/{userId}/clones/{cloneId} path. Only the user can manage their clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (create) User with UID 'testUID' can create a clone under their profile.
     * @allow (get, list, update, delete) User with UID 'testUID' can manage their clones.
     * @deny (create) User with UID 'otherUID' cannot create a clone for user 'testUID'.
     * @deny (get, list, update, delete) User with UID 'otherUID' cannot manage clones for user 'testUID'.
     * @principle Restricts access to a user's own clone data.
     */
    match /users/{userId}/clones/{cloneId} {
      // Only the user can create a clone.
      allow create: if isOwner(userId) && isValidOwnerCreateRequest('userId');
      // Only the user can read their own clones.
      allow get: if isOwner(userId);
      // Only the user can list their own clones.
      allow list: if isOwner(userId);
      // Only the user can update their own clones, but the userId must not change.
      allow update: if isExistingOwner(userId) && isValidOwnerUpdateRequest('userId');
      // Only the user can delete their own clones.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures the /users/{userId}/agents/{agentId} path. Only the user can manage their agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (create) User with UID 'testUID' can create an agent under their profile.
     * @allow (get, list, update, delete) User with UID 'testUID' can manage their agents.
     * @deny (create) User with UID 'otherUID' cannot create an agent for user 'testUID'.
     * @deny (get, list, update, delete) User with UID 'otherUID' cannot manage agents for user 'testUID'.
     * @principle Restricts access to a user's own agent data.
     */
    match /users/{userId}/agents/{agentId} {
      // Only the user can create an agent.
      allow create: if isOwner(userId);
      // Only the user can read their own agents.
      allow get: if isOwner(userId);
      // Only the user can list their own agents.
      allow list: if isOwner(userId);
      // Only the user can update their own agents.
      allow update: if isExistingOwner(userId);
      // Only the user can delete their own agents.
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secures the /products/{productId} path. Allows public read, but restricts writes to the product owner.
     * @path /products/{productId}
     * @allow (get, list) Any user can read any product.
     * @allow (create) User with UID 'testUID' can create a product with ownerId 'testUID'.
     * @allow (update, delete) User with UID 'testUID' can update/delete their product if resource.data.ownerId == 'testUID'.
     * @deny (create) User with UID 'otherUID' cannot create a product with ownerId 'testUID'.
     * @deny (update, delete) User with UID 'otherUID' cannot update/delete the product of 'testUID'.
     * @principle Allows public read access, but enforces document ownership for writes.
     */
    match /products/{productId} {
      // Anyone can read products.
      allow get, list: if true;
      // Only the owner can create a product.
      allow create: if isSignedIn() && isValidOwnerCreateRequest('ownerId');
      // Only the owner can update or delete their own product.
      allow update: if isExistingOwner(resource.data.ownerId) && isValidOwnerUpdateRequest('ownerId');
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Secures the /orders/{orderId} path. Anyone can read orders. Only system/backend can perform CRUD operations.
     * @path /orders/{orderId}
     * @allow (get, list) Any user can read any order.
     * @deny (create, update, delete) No one can create/update/delete orders.
     * @principle Open read, closed write.
     */
    match /orders/{orderId} {
      // Anyone can read orders
      allow get, list: if true;
      // Only the backend can perform CRUD operations, write operation are denied to all users
      allow create, update, delete: if false;
    }

    /**
     * @description Secures the /payments/{paymentId} path. Anyone can read payments. Only system/backend can perform CRUD operations.
     * @path /payments/{paymentId}
     * @allow (get, list) Any user can read any payment.
     * @deny (create, update, delete) No one can create/update/delete payments.
     * @principle Open read, closed write.
     */
    match /payments/{paymentId} {
      // Anyone can read payments
      allow get, list: if true;
      // Only the backend can perform CRUD operations, write operation are denied to all users
      allow create, update, delete: if false;
    }

    /**
     * @description Secures the /plans/{planId} path. Anyone can read plans. Only system/backend can perform CRUD operations.
     * @path /plans/{planId}
     * @allow (get, list) Any user can read any plan.
     * @deny (create, update, delete) No one can create/update/delete plans.
     * @principle Open read, closed write.
     */
    match /plans/{planId} {
      // Anyone can read plans
      allow get, list: if true;
      // Only the backend can perform CRUD operations, write operation are denied to all users
      allow create, update, delete: if false;
    }

    /**
     * @description Secures the /calls/{callId} path. Anyone can read calls. Only system/backend can perform CRUD operations.
     * @path /calls/{callId}
     * @allow (get, list) Any user can read any call.
     * @deny (create, update, delete) No one can create/update/delete calls.
     * @principle Open read, closed write.
     */
    match /calls/{callId} {
      // Anyone can read calls
      allow get, list: if true;
      // Only the backend can perform CRUD operations, write operation are denied to all users
      allow create, update, delete: if false;
    }

    /**
     * @description Secures the /transactions/{txId} path. Anyone can read transactions. Only system/backend can perform CRUD operations.
     * @path /transactions/{txId}
     * @allow (get, list) Any user can read any transaction.
     * @deny (create, update, delete) No one can create/update/delete transactions.
     * @principle Open read, closed write.
     */
    match /transactions/{txId} {
      // Anyone can read transactions
      allow get, list: if true;
      // Only the backend can perform CRUD operations, write operation are denied to all users
      allow create, update, delete: if false;
    }

    /**
     * @description Secures the /adminSettings/{settingId} path.
     * @path /adminSettings/{settingId}
     * @deny (get, list, create, update, delete) No one can access admin settings.
     * @principle Closed access.
     */
    match /adminSettings/{settingId} {
      // Only the backend can perform CRUD operations, write operation are denied to all users
      allow get, list, create, update, delete: if false;
    }

    /**
     * @description Secures the /adminAgents/{agentId} path.
     * @path /adminAgents/{agentId}
     * @deny (get, list, create, update, delete) No one can access admin agents.
     * @principle Closed access.
     */
    match /adminAgents/{agentId} {
      // Only the backend can perform CRUD operations, write operation are denied to all users
      allow get, list, create, update, delete: if false;
    }
    
    /**
     * @description Secures the /buyerTrust/{buyerId} path. Only the buyer can access their trust info.
     * @path /buyerTrust/{buyerId}
     * @allow (get) User with UID 'testUID' can read their trust info if request.auth.uid == 'testUID'.
     * @deny (get) User with UID 'otherUID' cannot read the trust info of 'testUID'.
     */
    match /buyerTrust/{buyerId} {
      // Only the buyer can read their own trust info
      allow get: if isOwner(buyerId);
      allow list: if false;
      // No one can create, update, or delete trust info
      allow create, update, delete: if false;
    }
  }
}