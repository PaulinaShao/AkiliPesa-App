/**
 * @fileoverview Firestore Security Rules for AkiliPesa application.
 *
 * Core Philosophy:
 * This ruleset enforces a combination of user-ownership and public-read/owner-write access control patterns.
 * User-specific data is secured under the `/users/{userId}` path, ensuring that only the authenticated user can access their own data.
 * Top-level collections like `/posts`, `/products` and `/adminAgents` allow for public reads but restrict writes to the owner of the resource.
 *
 * Data Structure:
 * Data is organized hierarchically, with user profiles stored under `/users/{userId}` and their associated data (clones, agents) nested under that.
 * Other data like posts, products, orders, and payments are stored in top-level collections.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect privacy.
 * - `adminAgents` are intended to be publicly readable but only created/managed by admins (currently emulated by owner).
 * - Read-only collections such as `plans` allow public read access to all documents.
 *
 * Denormalization for Authorization:
 * To avoid costly `get()` operations in the rules, ensure that documents in top-level collections contain an explicit ownership field (e.g., `authorId`, `ownerId`).
 * The `create` rule MUST validate that the incoming ownership field matches the user's auth UID.
 * The `update` and `delete` rules MUST validate ownership against the existing document's ownership field.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Authentication.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the request is made by the owner of the document.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Authorization.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the request is made by the existing owner of the document.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Authorization and existence check for updates and deletes.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
   /**
     * @description Secure user profiles. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their profile at /users/user123.
     * @deny (create) User with UID 'user123' cannot create a profile at /users/user456.
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user posts. Allows public read but restricts writes to the owner.
     * @path /posts/{postId}
     * @allow (get, list) Any user can read any post.
     * @allow (create) User with UID 'user123' can create a post with authorId: 'user123'.
     * @deny (create) User with UID 'user123' cannot create a post with authorId: 'user456'.
     * @deny (update, delete) User with UID 'user123' cannot update/delete a post they don't own.
     * @principle Public read, owner-only writes.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.authorId) && resource != null;
      allow delete: if isSignedIn() && isOwner(resource.data.authorId) && resource != null;
    }

    /**
     * @description Secure user clones. Only the authenticated user can read/write their own clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (create) User with UID 'user123' can create a clone under /users/user123/clones/clone1.
     * @deny (create) User with UID 'user123' cannot create a clone under /users/user456/clones/clone1.
     * @principle Enforces user-ownership for clone data.
     */
    match /users/{userId}/clones/{cloneId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user agents. Only the authenticated user can read/write their own agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (create) User with UID 'user123' can create an agent under /users/user123/agents/agent1.
     * @deny (create) User with UID 'user123' cannot create an agent under /users/user456/agents/agent1.
     * @principle Enforces user-ownership for agent data.
     */
    match /users/{userId}/agents/{agentId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure products. Allows public read but restricts writes to the owner.
     * @path /products/{productId}
     * @allow (get, list) Any user can read any product.
     * @allow (create) User with UID 'user123' can create a product with ownerId: 'user123'.
     * @deny (create) User with UID 'user123' cannot create a product with ownerId: 'user456'.
     * @deny (update, delete) User with UID 'user123' cannot update/delete a product they don't own.
     * @principle Public read, owner-only writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isOwner(resource.data.ownerId) && resource != null;
      allow delete: if isSignedIn() && isOwner(resource.data.ownerId) && resource != null;
    }

    /**
     * @description Secure orders. Only allow access to the buyer and seller.
     * @path /orders/{orderId}
     * @allow (get) Buyer or seller can get order details.
     * @deny (get) User who is not the buyer or seller cannot get order details.
     * @principle Shared access between buyer and seller.
     */
    match /orders/{orderId} {
        allow get: if isSignedIn() && (request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.sellerId);
        allow list: if false;
        allow create: if isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid);
        allow update: if isSignedIn() && (request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.sellerId) && resource != null;
        allow delete: if false;
    }

    /**
     * @description Secure payments. Payments should only be readable by the involved parties.
     * @path /payments/{paymentId}
     * @allow (get) Payment accessible to the seller.
     * @deny (get) Payment details not accessible to unauthorized users.
     * @principle Restricts payment data to relevant parties.
     */
    match /payments/{paymentId} {
        allow get: if isSignedIn() && request.auth.uid == resource.data.sellerId;
        allow list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Publicly accessible plans.
     * @path /plans/{planId}
     * @allow (get, list) Any user can read any plan.
     * @principle Public read access for all plans.
     */
    match /plans/{planId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure calls. Only allow access to participants.
     * @path /calls/{callId}
     *  @allow (get) Only the caller or agent involved in the call can read the call details.
     * @deny (get) Users not part of the call cannot access the call details.
     * @principle Restricts call data to involved parties.
     */
    match /calls/{callId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.callerId || request.auth.uid == resource.data.agentId);
      allow list: if false;
      allow create: if isSignedIn() && (request.resource.data.callerId == request.auth.uid || request.resource.data.agentId == request.auth.uid);
      allow update: if isSignedIn() && (request.auth.uid == resource.data.callerId || request.auth.uid == resource.data.agentId) && resource != null;
      allow delete: if false;
    }

    /**
     * @description Secure transactions. Only the user associated with the transaction can access it.
     * @path /transactions/{txId}
     * @allow (get) User can read their own transaction details.
     * @deny (get) Users cannot read other users' transaction details.
     * @principle Enforces user-ownership for transaction data.
     */
    match /transactions/{txId} {
      allow get: if isSignedIn() && request.auth.uid == resource.data.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure admin settings. Restrict access to admins.
     * @path /adminSettings/{settingId}
     * @allow (get) Only admins can read admin settings.
     * @deny (get) Non-admins cannot read admin settings.
     * @principle Restricts access to admin settings to authorized users.
     */
    match /adminSettings/{settingId} {
        // TODO: Add proper admin role check
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

      /**
       * @description Secure admin agents. Allows public read but restricts writes to admins (emulated by owner for now).
       * @path /adminAgents/{agentId}
       * @allow (get, list) Any user can read any admin agent.
       * @allow (create) User with UID 'user123' can create an admin agent.
       * @deny (update, delete) User with UID 'user123' cannot update/delete an admin agent they don't own.
       * @principle Public read, admin-only writes.
       */
      match /adminAgents/{agentId} {
        allow get, list: if true;
        // TODO: Add proper admin role check
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if false;
      }
  }
}