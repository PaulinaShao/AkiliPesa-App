/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for most user-generated data,
 *              allowing users to read and write their own data while restricting access to others' data.
 *              Public read access is granted to certain collections like 'posts' to enable wider content sharing.
 *
 * @dataStructure
 *  - /users/{userId}: Stores user profiles. Each user can only access their own profile.
 *  - /posts/{postId}: Stores user-generated posts. Read access is public, but writes are restricted to the owner.
 *  - /users/{userId}/clones/{cloneId}: Stores user-specific digital clones. Only the owner can manage these.
 *  - /users/{userId}/agents/{agentId}: Stores user-specific AI agents. Only the owner can manage these.
 *  - /products/{productId}: Stores products. Read access is public, writes are owner-only.
 *  - /orders/{orderId}: Stores orders.
 *  - /payments/{paymentId}: Stores payment information.
 *  - /plans/{planId}: Stores subscription plans.  Read access is public.
 *  - /calls/{callId}: Stores call session data.
 *  - /transactions/{txId}: Stores transaction logs.
 *  - /adminSettings/{settingId}: Stores global admin settings.
 *  - /adminAgents/{agentId}: Stores admin-created AI agents.
 *
 * @keySecurityDecisions
 *  - User listing is generally disallowed to protect privacy.
 *  - Data validation is relaxed during this prototyping phase to allow for flexible data shapes.
 *  - Public collections such as `posts` require an `authorId` field for secure owner-based write rules.
 *  - Ambiguous relationships default to strict owner-only access.
 *
 * @denormalizationForAuthorization
 *  - The `posts` collection requires an `authorId` field on each document to enable public read access with owner-only writes.
 *    This avoids needing to query a separate collection to determine ownership.
 *  - Transactions should include the UID of the user involved in the transaction to easily authorize access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create, update, get) if the user is signed in and the userId matches the authenticated user's ID.
     * @deny (create, update, get) if the user is not signed in or the userId does not match the authenticated user's ID.
     * @principle Enforces document ownership for writes, restricts access to a user's own data.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Controls access to posts. Read access is public, but write access is restricted to the post's author.
     * @path /posts/{postId}
     * @allow (get, list) Public read access.
     * @allow (create) if the user is signed in and the authorId in the request matches the authenticated user's ID.
     * @allow (update, delete) if the user is signed in and the authorId in the existing document matches the authenticated user's ID.
     * @deny (create, update, delete) if the user is not signed in or the authorId does not match the authenticated user's ID.
     * @principle Public read, owner-only writes.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Controls access to user-specific digital clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (create, update, get) if the user is signed in and the userId matches the authenticated user's ID.
     * @deny (create, update, get) if the user is not signed in or the userId does not match the authenticated user's ID.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/clones/{cloneId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to user-specific AI agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (create, update, get) if the user is signed in and the userId matches the authenticated user's ID.
     * @deny (create, update, get) if the user is not signed in or the userId does not match the authenticated user's ID.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId}/agents/{agentId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to products. Read access is public, writes are owner-only.
     * @path /products/{productId}
     * @allow (get, list) Public read access.
     * @allow (create) if the user is signed in and the ownerId in the request matches the authenticated user's ID.
     * @allow (update, delete) if the user is signed in and the ownerId in the existing document matches the authenticated user's ID.
     * @deny (create, update, delete) if the user is not signed in or the ownerId does not match the authenticated user's ID.
     * @principle Public read, owner-only writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Controls access to orders.
     * @path /orders/{orderId}
     * @allow get: if false;
     * @allow list: if false;
     * @allow create: if false;
     * @allow update: if false;
     * @allow delete: if false;
     */
    match /orders/{orderId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to payment information.
     * @path /payments/{paymentId}
     * @allow get: if false;
     * @allow list: if false;
     * @allow create: if false;
     * @allow update: if false;
     * @allow delete: if false;
     */
    match /payments/{paymentId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to subscription plans. Read access is public.
     * @path /plans/{planId}
     * @allow get, list: if true;
     * @allow create: if false;
     * @allow update: if false;
     * @allow delete: if false;
     */
    match /plans/{planId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to call session data.
     * @path /calls/{callId}
     * @allow get: if false;
     * @allow list: if false;
     * @allow create: if false;
     * @allow update: if false;
     * @allow delete: if false;
     */
    match /calls/{callId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to transaction logs.
     * @path /transactions/{txId}
     */
    match /transactions/{txId} {
      allow get: if isSignedIn() && resource.data.uid == request.auth.uid;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to global admin settings.
     * @path /adminSettings/{settingId}
     */
    match /adminSettings/{settingId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to admin-created AI agents.
     * @path /adminAgents/{agentId}
     */
    match /adminAgents/{agentId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isExistingOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId && resource != null;
    }
  }
}