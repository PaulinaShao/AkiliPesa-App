/**
 * @fileoverview Firestore Security Rules for AkiliPesa application.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure access control, enforcing strict ownership for user-specific data
 * and providing public read access where appropriate. Data shape validation is relaxed for rapid prototyping.
 *
 * Data Structure:
 * - User profiles are stored under `/users/{userId}` and are owned by the respective user.
 * - User-generated content (clones, agents) are stored under the user's profile.
 * - Products, orders, payments, and transactions are stored in top-level collections with owner/buyer/seller IDs for access control.
 * - Admin settings and agents are stored in their respective top-level collections.
 *
 * Key Security Decisions:
 * - Listing of user profiles is disallowed to prevent enumeration.
 * - Public read access is granted for the `posts`, `products`, `plans`, and `adminAgents` collections,
 *   but writes are restricted to owners.
 * - Helper functions are used to encapsulate complex authorization logic for better readability and maintainability.
 *
 * Denormalization for Authorization:
 * To ensure security and performance, authorization relies on denormalized data within documents.
 * For example, product documents contain `ownerId` to simplify owner-based access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by an authenticated user.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Authentication is required for most operations.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user ID matches the owner ID in the resource data.
     * @path N/A
     * @allow N/A
     * @deny N/A
     * @principle Enforces user ownership for existing documents.
     */
    function isExistingOwner(ownerId) {
        return isSignedIn() && isOwner(ownerId) && resource != null;
    }

    /**
     * @description Enforces ownership for user profiles.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user123' creates their profile.
     * @deny (create) - User with UID 'user123' tries to create a profile for 'user456'.
     * @principle Enforces document ownership.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access but enforces owner-only writes for posts.
     * @path /posts/{postId}
     * @allow (get, list) - Any user can read all posts.
     * @allow (create) - User with UID 'user123' creates a post with authorId: 'user123'.
     * @deny (create) - User with UID 'user123' creates a post with authorId: 'user456'.
     * @deny (update, delete) - User with UID 'user456' tries to modify a post owned by 'user123'.
     * @principle Public read, owner-only write.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Enforces ownership for user-specific clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (create) - User with UID 'user123' creates a clone under their profile.
     * @deny (create) - User with UID 'user123' tries to create a clone under 'user456' profile.
     * @principle Enforces document ownership within a user subcollection.
     */
    match /users/{userId}/clones/{cloneId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Enforces ownership for user-specific agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (create) - User with UID 'user123' creates an agent under their profile.
     * @deny (create) - User with UID 'user123' tries to create an agent under 'user456' profile.
     * @principle Enforces document ownership within a user subcollection.
     */
    match /users/{userId}/agents/{agentId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access but enforces owner-only writes for products.
     * @path /products/{productId}
     * @allow (get, list) - Any user can read all products.
     * @allow (create) - User with UID 'user123' creates a product with ownerId: 'user123'.
     * @deny (create) - User with UID 'user123' creates a product with ownerId: 'user456'.
     * @deny (update, delete) - User with UID 'user456' tries to modify a product owned by 'user123'.
     * @principle Public read, owner-only write.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Orders can be read by buyer or seller. Only the seller can update the order. No public listing.
     * @path /orders/{orderId}
     * @allow (get) - User with UID 'user123' reads an order where buyerId or sellerId is 'user123'.
     * @deny (get) - User with UID 'user123' tries to read an order where neither buyerId nor sellerId is 'user123'.
     * @allow (update) - User with UID 'user123' updates an order where sellerId is 'user123'.
     * @deny (update) - User with UID 'user123' tries to update an order where sellerId is 'user456'.
     * @principle Shared access based on buyer/seller relationship, seller-only updates.
     */
    match /orders/{orderId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.buyerId || request.auth.uid == resource.data.sellerId);
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.buyerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.sellerId);
      allow delete: if false;
    }

   /**
    * @description Payments can only be read if the authenticated user is the seller.
    * @path /payments/{paymentId}
    * @allow (get) - User with UID 'user123' reads a payment where sellerId is 'user123'.
    * @deny (get) - User with UID 'user123' tries to read a payment where sellerId is 'user456'.
    * @principle Seller-only access to payment information.
    */
    match /payments/{paymentId} {
      allow get: if isSignedIn() && request.auth.uid == resource.data.sellerId;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to subscription plans.
     * @path /plans/{planId}
     * @allow (get, list) - Any user can read all plans.
     * @principle Public read access.
     */
    match /plans/{planId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Calls data can only be read by the caller or the agent.
     * @path /calls/{callId}
     * @allow (get) - User with UID 'user123' reads a call where callerId or agentId is 'user123'.
     * @deny (get) - User with UID 'user123' tries to read a call where neither callerId nor agentId is 'user123'.
     * @principle Shared access based on caller/agent relationship.
     */
    match /calls/{callId} {
      allow get: if isSignedIn() && (request.auth.uid == resource.data.callerId || request.auth.uid == resource.data.agentId);
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == resource.data.callerId;
      allow update: if isSignedIn() && (request.auth.uid == resource.data.callerId || request.auth.uid == resource.data.agentId);
      allow delete: if false;
    }

    /**
     * @description Transactions can only be read or created by the user who owns the transaction.
     * @path /transactions/{txId}
     * @allow (get) - User with UID 'user123' reads a transaction where uid is 'user123'.
     * @deny (get) - User with UID 'user123' tries to read a transaction where uid is 'user456'.
     * @principle User-only access to transaction history.
     */
    match /transactions/{txId} {
      allow get: if isSignedIn() && request.auth.uid == resource.data.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Only admins can read admin settings.  No public listing.
     * @path /adminSettings/{settingId}
     * @allow (get) - Only an admin can get this data
     * @principle Admin-only access.
     */
    match /adminSettings/{settingId} {
      allow get: if false; // TODO: Add admin role check
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to admin agents.
     * @path /adminAgents/{agentId}
     * @allow (get, list) - Any user can read all admin agents.
     * @principle Public read access.
     */
    match /adminAgents/{agentId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}