/**
 * @file Firebase Security Rules for AkiliPesa
 *
 * @core_philosophy This ruleset enforces a hybrid security model. User-specific data is strictly controlled via
 * owner-only access. Public content is readable by all, but writable only by authorized users or under very
 * specific conditions (e.g., self-creation). The rules prioritize secure data access based on user identity
 * and role. No user listing is allowed for privacy.
 *
 * @data_structure
 * - `/users/{userId}`: User profile data.
 * - `/posts/{postId}`: Public posts created by users.
 * - `/users/{userId}/clones/{cloneId}`: User-owned digital clones.
 * - `/users/{userId}/agents/{agentId}`: User-owned AI agents.
 * - `/products/{productId}`: Public product listings.
 * - `/orders/{orderId}`: Order information, accessible to buyer and seller.
 * - `/payments/{paymentId}`: Payment details, accessible to seller.
 * - `/plans/{planId}`: Subscription plan definitions (publicly readable).
 * - `/calls/{callId}`: Call session records.
 * - `/transactions/{txId}`: Transaction history.
 * - `/adminSettings/{settingId}`: Global admin settings (restricted access).
 * - `/adminAgents/{agentId}`: Admin-created AI agents (restricted access).
 *
 * @key_security_decisions
 * - User listing is disallowed for privacy reasons.
 * - Public read access is granted to certain collections (e.g., `/posts`, `/products`, `/plans`).
 * - Write access to public collections is restricted to authenticated users, with ownership validation.
 * - Documents under `/users/{userId}` are strictly owner-controlled.
 * - `update` and `delete` operations always check for document existence (`resource != null`).
 * - Assumes no pre-existing data - designed for greenfield deployment.
 * - All timestamps are strings and not validated.
 *
 * @denormalization_for_authorization
 * - Posts should contain an `authorId` field.
 * - Products should contain an `ownerId` field.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) User with UID 'testUID' can create their profile if request.auth.uid == userId.
     * @allow (get) User with UID 'testUID' can read their own profile data.
     * @allow (update) User with UID 'testUID' can update their profile.
     * @allow (delete) User with UID 'testUID' can delete their own profile.
     * @deny (create) User with UID 'otherUID' cannot create a profile for user 'testUID'.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.uid == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Manages publicly accessible posts.
     * @path /posts/{postId}
     * @allow (get) Any user can read any post.
     * @allow (list) Any user can list posts.
     * @allow (create) User with UID 'testUID' can create a post with authorId 'testUID'.
     * @allow (update) User with UID 'testUID' can update their own post with authorId 'testUID'.
     * @allow (delete) User with UID 'testUID' can delete their own post with authorId 'testUID'.
     * @deny (create) User with UID 'otherUID' cannot create a post for authorId 'testUID'.
     * @principle Allows public reads with owner-only writes, validating ownership on creation.
     */
    match /posts/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(authorId) {
        return request.auth.uid == authorId;
      }

      function isExistingOwner(authorId) {
        return isSignedIn() && isOwner(authorId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages user-specific digital clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (create) User with UID 'testUID' can create a clone under their profile.
     * @allow (get) User with UID 'testUID' can read their own clone data.
     * @allow (list) User with UID 'testUID' can list their own clones.
     * @allow (update) User with UID 'testUID' can update their own clone.
     * @allow (delete) User with UID 'testUID' can delete their own clone.
     * @deny (create) User with UID 'otherUID' cannot create a clone for user 'testUID'.
     * @principle Enforces strict user ownership.
     */
    match /users/{userId}/clones/{cloneId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user-specific AI agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (create) User with UID 'testUID' can create an agent under their profile.
     * @allow (get) User with UID 'testUID' can read their own agent data.
     * @allow (list) User with UID 'testUID' can list their own agents.
     * @allow (update) User with UID 'testUID' can update their own agent.
     * @allow (delete) User with UID 'testUID' can delete their own agent.
     * @deny (create) User with UID 'otherUID' cannot create an agent for user 'testUID'.
     * @principle Enforces strict user ownership.
     */
    match /users/{userId}/agents/{agentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isSignedIn() && isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == agentId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages publicly accessible product listings.
     * @path /products/{productId}
     * @allow (get) Any user can read any product.
     * @allow (list) Any user can list products.
     * @allow (create) User with UID 'testUID' can create a product with ownerId 'testUID'.
     * @allow (update) User with UID 'testUID' can update their own product with ownerId 'testUID'.
     * @allow (delete) User with UID 'testUID' can delete their own product with ownerId 'testUID'.
     * @deny (create) User with UID 'otherUID' cannot create a product for ownerId 'testUID'.
     * @principle Allows public reads with owner-only writes, validating ownership on creation.
     */
    match /products/{productId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }

      function isExistingOwner(ownerId) {
        return isSignedIn() && isOwner(ownerId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Manages order information.
     * @path /orders/{orderId}
     * @allow (get) User with UID 'testUID' can read an order where they are the buyer or seller.
     * @allow (list) User with UID 'testUID' can list orders where they are the buyer or seller.
     * @allow (create) Any signed-in user can create an order.
     * @allow (update) User with UID 'testUID' (buyer or seller) can update the order.
     * @allow (delete) User with UID 'testUID' (buyer or seller) can delete the order.
     * @deny (get) User with UID 'otherUID' cannot read an order where they are neither buyer nor seller.
     * @principle Allows access to orders for involved parties (buyer/seller).
     */
    match /orders/{orderId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isBuyerOrSeller(buyerId, sellerId) {
        return request.auth.uid == buyerId || request.auth.uid == sellerId;
      }

      function isExistingBuyerOrSeller(buyerId, sellerId) {
        return isSignedIn() && isBuyerOrSeller(buyerId, sellerId) && resource != null;
      }

      allow get: if isSignedIn() && isBuyerOrSeller(resource.data.buyerId, resource.data.sellerId);
      allow list: if false; // disable listing for now
      allow create: if isSignedIn();
      allow update: if isExistingBuyerOrSeller(resource.data.buyerId, resource.data.sellerId);
      allow delete: if isExistingBuyerOrSeller(resource.data.buyerId, resource.data.sellerId);
    }

    /**
     * @description Manages payment details.
     * @path /payments/{paymentId}
     * @allow (get) Seller with UID 'testUID' can read their payment details.
     * @allow (list) Seller with UID 'testUID' can list their payments
     * @allow (create) Any signed-in user can create a payment record.
     * @allow (update) Seller with UID 'testUID' can update payment information.
     * @allow (delete) Seller with UID 'testUID' can delete payment record
     * @deny (get) User with UID 'otherUID' cannot read payment details of seller 'testUID'.
     * @principle Restricts payment access to the seller involved.
     */
    match /payments/{paymentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isSeller(sellerId) {
        return request.auth.uid == sellerId;
      }

      function isExistingSeller(sellerId) {
        return isSignedIn() && isSeller(sellerId) && resource != null;
      }

      allow get: if isSignedIn() && isSeller(resource.data.sellerId);
      allow list: if false; // disable listing for now.
      allow create: if isSignedIn();
      allow update: if isExistingSeller(resource.data.sellerId);
      allow delete: if isExistingSeller(resource.data.sellerId);
    }

    /**
     * @description Manages publicly accessible subscription plan definitions.
     * @path /plans/{planId}
     * @allow (get) Any user can read any plan.
     * @allow (list) Any user can list plans.
     * @deny (create) No one can create plans via the client.
     * @deny (update) No one can update plans via the client.
     * @deny (delete) No one can delete plans via the client.
     * @principle Allows public reads, but restricts writes.
     */
    match /plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages call session records.
     * @path /calls/{callId}
     * @allow (get) Caller or Agent with UID 'testUID' can read call details.
     * @allow (list) User with UID 'testUID' can list calls where they are caller or agent.
     * @allow (create) Any authenticated user can create a call record.
     * @allow (update) Caller or Agent with UID 'testUID' can update their call information.
     * @allow (delete) Caller or Agent with UID 'testUID' can delete call record
     * @deny (get) User with UID 'otherUID' cannot read call details of caller/agent 'testUID'.
     * @principle Restricts call access to involved parties.
     */
    match /calls/{callId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isCallerOrAgent(callerId, agentId) {
        return request.auth.uid == callerId || request.auth.uid == agentId;
      }

      function isExistingCallerOrAgent(callerId, agentId) {
        return isSignedIn() && isCallerOrAgent(callerId, agentId) && resource != null;
      }

      allow get: if isSignedIn() && isCallerOrAgent(resource.data.callerId, resource.data.agentId);
      allow list: if false; // disabled for now
      allow create: if isSignedIn();
      allow update: if isExistingCallerOrAgent(resource.data.callerId, resource.data.agentId);
      allow delete: if isExistingCallerOrAgent(resource.data.callerId, resource.data.agentId);
    }

    /**
     * @description Manages transaction history.
     * @path /transactions/{txId}
     * @allow (get) User with UID 'testUID' can read their own transaction details.
     * @allow (list) User with UID 'testUID' can list their own transactions.
     * @allow (create) Any signed-in user can create a transaction.
     * @allow (update) User with UID 'testUID' can update their own transaction information.
     * @allow (delete) User with UID 'testUID' can delete their own transaction record.
     * @deny (get) User with UID 'otherUID' cannot read transaction details of user 'testUID'.
     * @principle Enforces user-specific transaction access.
     */
    match /transactions/{txId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(uid) {
        return request.auth.uid == uid;
      }

      function isExistingOwner(uid) {
        return isSignedIn() && isOwner(uid) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(resource.data.uid);
      allow list: if isSignedIn() && isOwner(resource.data.uid);
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.uid);
      allow delete: if isExistingOwner(resource.data.uid);
    }

    /**
     * @description Manages global admin settings.
     * @path /adminSettings/{settingId}
     * @deny (get) No one can read admin settings via the client.
     * @deny (list) No one can list admin settings via the client.
     * @deny (create) No one can create admin settings via the client.
     * @deny (update) No one can update admin settings via the client.
     * @deny (delete) No one can delete admin settings via the client.
     * @principle Restricts all client access to admin settings.
     */
    match /adminSettings/{settingId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages admin-created AI agents.
     * @path /adminAgents/{agentId}
     * @deny (get) No one can read admin agents via the client.
     * @deny (list) No one can list admin agents via the client.
     * @deny (create) No one can create admin agents via the client.
     * @deny (update) No one can update admin agents via the client.
     * @deny (delete) No one can delete admin agents via the client.
     * @principle Restricts all client access to admin agents.
     */
    match /adminAgents/{agentId} {
      allow get: if false;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}