/**
 * @fileoverview Firestore Security Rules for AkiliPesa application.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure access control, enforcing strict ownership for user-specific data
 * and providing public read access where appropriate. Data shape validation is relaxed for rapid prototyping.
 *
 * Data Structure:
 * - User profiles are stored under /users/{userId}.
 * - User-generated content (clones, agents) is nested under the respective user's document.
 * - Products, orders, payments, transactions, plans, calls, admin settings, and admin agents are stored
 *   in top-level collections.
 *
 * Key Security Decisions:
 * - Users can only access their own profiles and related subcollections.
 * - Listing of user documents is disallowed.
 * - Public read access is granted to the top-level 'products', 'plans' and 'adminAgents' collections,
 *   but writes are restricted to owners or admin roles (where applicable).
 * - Data validation is minimized to focus on authorization and relational integrity.
 *
 * Denormalization for Authorization:
 *  - The `Post` entity requires denormalization to function properly. Posts should contain the `authorId` to link to the user.
 *  - Similarly, ensure that entities like `Product`, `Order`, `Payment`, and `Transaction` contain the necessary
 *    `ownerId` or `userId` fields for proper authorization.
 * Structural Segregation:
 * - Private user data (profiles, clones, agents) is stored in user-specific subcollections, while public data
 *   (products, plans) is stored in top-level collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     * @return {bool} True if the UIDs match, false otherwise.
     * @example isOwner('someUserId') -> true if request.auth.uid == 'someUserId'
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId and the resource exists.
     * @param {string} userId - The user ID to compare against the authenticated user's UID.
     * @return {bool} True if the UIDs match and the resource exists, false otherwise.
     * @example isExistingOwner('someUserId') -> true if request.auth.uid == 'someUserId' && resource != null
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) - User can create their own profile if the userId matches their auth UID.
     * @allow (get, update, delete) - User can get, update, and delete their own profile if the userId matches their auth UID.
     * @deny (create) - User cannot create a profile with a userId that does not match their auth UID.
     * @deny (get, update, delete) - User cannot get, update, and delete a profile with a userId that does not match their auth UID.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.uid == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.uid == resource.data.uid;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (create, get, update, delete, list) - User can manage their own clones.
     * @deny (create, get, update, delete, list) - User cannot manage clones that do not belong to them.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/clones/{cloneId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (create, get, update, delete, list) - User can manage their own agents.
     * @deny (create, get, update, delete, list) - User cannot manage agents that do not belong to them.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/agents/{agentId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for posts.
     * @path /posts/{postId}
     * @allow (get, list) - Anyone can read posts.
     * @allow (create) - User can create a post if the authorId matches their auth UID.
     * @allow (update, delete) - User can update and delete their own posts.
     * @deny (create) - User cannot create a post with an authorId that does not match their auth UID.
     * @deny (update, delete) - User cannot update and delete posts that do not belong to them.
     * @principle Public read with owner-only writes.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for products.
     * @path /products/{productId}
     * @allow (get, list) - Anyone can read products.
     * @allow (create) - User can create a product if the ownerId matches their auth UID.
     * @allow (update, delete) - User can update and delete their own products.
     * @deny (create) - User cannot create a product with an ownerId that does not match their auth UID.
     * @deny (update, delete) - User cannot update and delete products that do not belong to them.
     * @principle Public read with owner-only writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rules for orders.
     * @path /orders/{orderId}
     *  // TODO: Add owner validation once the schema is updated with an ownership field.
     * @allow (get, list) - Anyone can read orders.
     *  @principle Public read with owner-only writes.
     */
    match /orders/{orderId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for payments.
     * @path /payments/{paymentId}
     * @allow (get, list) - Anyone can read payments.
     *  // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read with owner-only writes.
     */
    match /payments/{paymentId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for plans.
     * @path /plans/{planId}
     * @allow (get, list) - Anyone can read plans.
     *  @principle Public read with owner-only writes.
     */
    match /plans/{planId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Determine admin write rules
    }

    /**
     * @description Rules for calls.
     * @path /calls/{callId}
     * @allow (get, list) - Anyone can read calls.
     *  // TODO: Add owner validation once the schema is updated with an ownership field.
     *  @principle Public read with owner-only writes.
     */
    match /calls/{callId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Determine admin/user write rules
    }

    /**
     * @description Rules for transactions.
     * @path /transactions/{txId}
     * @allow (create, get, update, delete, list) - User can manage their own transactions.
     * @deny (create, get, update, delete, list) - User cannot manage transactions that do not belong to them.
     * @principle Restricts access to a user's own data tree.
     */
    match /transactions/{txId} {
      allow get, list: if isSignedIn(); // Everyone who is signed in can view transactions.
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rules for admin settings.
     * @path /adminSettings/{settingId}
     *  @principle Admin only writes
     */
    match /adminSettings/{settingId} {
      allow get: if true;
      allow list: if false;
      allow create, update, delete: if false; // TODO: Add admin role check.
    }

      /**
       * @description Rules for admin agents.
       * @path /adminAgents/{agentId}
       * @allow (get, list) - Anyone can read admin agents.
       * @principle Public read, Admin write.
       */
    match /adminAgents/{agentId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check.
    }
  }
}