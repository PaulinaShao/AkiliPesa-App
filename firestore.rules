/**
 * @fileoverview Firestore Security Rules for AkiliPesa Application
 *
 * Core Philosophy:
 * This ruleset prioritizes user data protection by enforcing strict ownership-based access control for user-specific data.
 * Publicly accessible data is carefully managed, and administrative settings are highly protected.
 *
 * Data Structure:
 * - User profiles and associated data (clones, agents) are nested under `/users/{userId}`.
 * - Public content (posts, products) resides in top-level collections like `/posts` and `/products`.
 * - Orders, Payments, Transactions, Plans and Calls reside in top-level collections.
 * - Admin settings and agents are stored under `/adminSettings` and `/adminAgents`, respectively.
 *
 * Key Security Decisions:
 * - User listing is disallowed to protect user privacy.
 * - Strict ownership is enforced for all user-specific resources, using the `isOwner()` helper function.
 * - Public read access is granted for `/posts` and `/products`, but writes are restricted to the owner. The `posts` and `products` documents
 *   MUST contain `authorId` and `ownerId` to enforce owner-only writes.
 * - Admin settings are only accessible by authenticated users to prevent unauthorized modifications. This can be expanded later.
 *
 * Denormalization for Authorization:
 *  - To simplify rules and avoid costly `get()` operations, the `Post` entity requires an `authorId` field that must match the authenticated user's UID for write operations.
 *  - The `Product` entity requires an `ownerId` field that must match the authenticated user's UID for write operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Only the authenticated user can read and write their own profile.
     * @path /users/{userId}
     * @allow (get, update, delete) User 'testuser' with uid 'testuid' can get, update, and delete their own profile at /users/testuid.
     * @allow (create) User 'testuser' with uid 'testuid' can create their own profile at /users/testuid.
     * @deny (get, update, delete) User 'otheruser' with uid 'otheruid' cannot get, update, or delete the profile at /users/testuid.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      // Function to check if the authenticated user is the owner of the document
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      // Function to check if the authenticated user is the existing owner of the document
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
        allow get: if isOwner(userId);
        allow list: if false;
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user posts. Allows public reads but restricts writes to the post author.
     * @path /posts/{postId}
     * @allow (get, list) Any user can read any post.
     * @allow (create) User 'testuser' with uid 'testuid' can create a post at /posts/testpost if request.resource.data.authorId == 'testuid'.
     * @allow (update, delete) User 'testuser' with uid 'testuid' can update/delete a post at /posts/testpost if resource.data.authorId == 'testuid'.
     * @deny (create) User 'otheruser' with uid 'otheruid' cannot create a post at /posts/testpost with authorId == 'testuid'.
     * @deny (update, delete) User 'otheruser' with uid 'otheruid' cannot update/delete a post at /posts/testpost even if resource.data.authorId == 'testuid'.
     * @principle Allows public reads with owner-only writes.
     */
    match /posts/{postId} {
      function isOwner(authorId) {
        return request.auth != null && request.auth.uid == authorId;
      }

      function isExistingOwner(authorId) {
          return isOwner(authorId) && resource != null;
      }

        allow get: if true;
        allow list: if true;
      allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Secure user clones. Only the authenticated user can manage their own clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (get, list, create, update, delete) User 'testuser' with uid 'testuid' can manage their clones under /users/testuid/clones/.
     * @deny (get, list, create, update, delete) User 'otheruser' with uid 'otheruid' cannot manage clones under /users/testuid/clones/.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/clones/{cloneId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user agents. Only the authenticated user can manage their own agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (get, list, create, update, delete) User 'testuser' with uid 'testuid' can manage their agents under /users/testuid/agents/.
     * @deny (get, list, create, update, delete) User 'otheruser' with uid 'otheruid' cannot manage agents under /users/testuid/agents/.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/agents/{agentId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure products. Allows public reads but restricts writes to the product owner.
     * @path /products/{productId}
     * @allow (get, list) Any user can read any product.
     * @allow (create) User 'testuser' with uid 'testuid' can create a product at /products/testproduct if request.resource.data.ownerId == 'testuid'.
     * @allow (update, delete) User 'testuser' with uid 'testuid' can update/delete a product at /products/testproduct if resource.data.ownerId == 'testuid'.
     * @deny (create) User 'otheruser' with uid 'otheruid' cannot create a product at /products/testproduct with ownerId == 'testuid'.
     * @deny (update, delete) User 'otheruser' with uid 'otheruid' cannot update/delete a product at /products/testproduct even if resource.data.ownerId == 'testuid'.
     * @principle Allows public reads with owner-only writes.
     */
    match /products/{productId} {
      function isOwner(ownerId) {
        return request.auth != null && request.auth.uid == ownerId;
      }

      function isExistingOwner(ownerId) {
          return isOwner(ownerId) && resource != null;
      }

        allow get: if true;
        allow list: if true;
      allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Secure orders.  Write operations are denied to prevent unauthorized modifications.
     * @path /orders/{orderId}
     * @allow (get, list) Any authenticated user can read any order.
     * @deny (create, update, delete) No user can create, update, or delete any order.
     * @principle  Restricts access to order data.
     */
    match /orders/{orderId} {
        allow get: if request.auth != null;
        allow list: if request.auth != null;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Secure payments. Write operations are denied to prevent unauthorized modifications.
     * @path /payments/{paymentId}
     * @allow (get, list) Any authenticated user can read any payment.
     * @deny (create, update, delete) No user can create, update, or delete any payment.
     * @principle Restricts access to payment data.
     */
    match /payments/{paymentId} {
        allow get: if request.auth != null;
        allow list: if request.auth != null;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Secure plans. Allows public reads and prevents writes.
     * @path /plans/{planId}
     * @allow (get, list) Any user can read any plan.
     * @deny (create, update, delete) No user can create, update, or delete any plan.
     * @principle Public read-only access for plans.
     */
    match /plans/{planId} {
        allow get: if true;
        allow list: if true;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Secure calls. Write operations are denied to prevent unauthorized modifications.
     * @path /calls/{callId}
     * @allow (get, list) Any authenticated user can read any call record.
     * @deny (create, update, delete) No user can create, update, or delete any call record.
     * @principle Restricts access to call data.
     */
    match /calls/{callId} {
        allow get: if request.auth != null;
        allow list: if request.auth != null;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Secure transactions.  Write operations are denied to prevent unauthorized modifications.
     * @path /transactions/{txId}
     * @allow (get, list) Any authenticated user can read any transaction.
     * @deny (create, update, delete) No user can create, update, or delete any transaction.
     * @principle Restricts access to transaction data.
     */
    match /transactions/{txId} {
        allow get: if request.auth != null;
        allow list: if request.auth != null;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Secure admin settings. Only authenticated users can read admin settings. Write operations are denied to prevent unauthorized modifications.
     * @path /adminSettings/{settingId}
     * @allow (get, list) Any authenticated user can read admin settings.
     * @deny (create, update, delete) No user can create, update, or delete any admin setting.
     * @principle Restricts access to admin settings.
     */
    match /adminSettings/{settingId} {
        allow get: if request.auth != null;
        allow list: if request.auth != null;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Secure admin agents. Write operations are denied to prevent unauthorized modifications.
     * @path /adminAgents/{agentId}
     * @allow (get, list) Any authenticated user can read any admin agent.
     * @deny (create, update, delete) No user can create, update, or delete any admin agent.
     * @principle Restricts access to admin agent data.
     */
    match /adminAgents/{agentId} {
        allow get: if request.auth != null;
        allow list: if request.auth != null;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }
  }
}