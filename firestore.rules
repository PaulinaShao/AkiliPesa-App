/**
 * @file Firestore Security Rules for AkiliPesa - Phase 8: AI-Verified Product Authenticity & Fraud Detection.
 *
 * @core_philosophy This ruleset enforces a hybrid security model, balancing user-owned data with public access for certain collections
 *  and administrator-controlled AI verification processes. It prioritizes strong authorization based on user identity and roles.
 *
 * @data_structure
 *  - User-specific data is nested under `/users/{userId}`.
 *  - Publicly accessible content (e.g., products, posts) resides in top-level collections like `/products` and `/posts`.
 *  - AI verification results are stored in `/productVerification/{id}`.
 *  - Flagged media reports are stored in `/mediaReports/{id}`.
 *  - Admin-related data is stored in `/adminSettings/{settingId}` and `/adminAgents/{agentId}`.
 *
 * @key_security_decisions
 *  - User listing is disallowed.
 *  - The `productVerification` collection is readable by any signed-in user but writable only by the admin.
 *  - The `mediaReports` collection is readable only by the admin.
 *  - Data validation is relaxed to allow for rapid prototyping, focusing on ownership and relational integrity checks.
 *
 * @denormalization_for_authorization Not applicable in this phase.
 *
 * @structural_segregation Public and private content is segregated into different collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by an authenticated user.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against the authenticated user ID.
     * @return {bool} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID and the resource exists.
     * @param {string} userId The user ID to compare against the authenticated user ID.
     * @return {bool} True if the user IDs match and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user's email is the admin's email.
     * @return {bool} True if the user is an admin, false otherwise.
     */
    function isAdmin() {
      return request.auth.token.email == "blagridigital@gmail.com";
    }


    /**
     * @description Security rules for user profiles.
     * @path /users/{userId}
     * @allow (create) If the authenticated user's ID matches the userId.
     * @allow (get, update, delete) If the authenticated user's ID matches the userId and the resource exists.
     * @deny (create) If the authenticated user's ID does not match the userId.
     * @deny (get, update, delete) If the authenticated user's ID does not match the userId or the resource does not exist.
     * @principle Enforces user ownership for profile access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for user clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (create, get, list, update, delete) If the authenticated user is the owner of the parent user document.
     * @deny (create) If the parent user document does not exist.
     * @principle Enforces user ownership of clones.
     */
    match /users/{userId}/clones/{cloneId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for user agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (create, get, list, update, delete) If the authenticated user is the owner of the parent user document.
     * @deny (create) If the parent user document does not exist.
     * @principle Enforces user ownership of agents.
     */
    match /users/{userId}/agents/{agentId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Security rules for products.
     * @path /products/{productId}
     * @allow (get, list) Public read access.
     * @allow (create) If the authenticated user's ID matches the product's ownerId.
     * @allow (update, delete) If the authenticated user's ID matches the product's ownerId and the resource exists.
     * @deny (create) If the authenticated user's ID does not match the product's ownerId.
     * @deny (update, delete) If the authenticated user's ID does not match the product's ownerId or the resource does not exist.
     * @principle Public read, owner-only writes with ownership validation.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Security rules for orders.
     * @path /orders/{orderId}
     * @allow (read, create, update, delete) If the authenticated user is the buyer or seller.
     * @deny (read, create, update, delete) If the authenticated user is not the buyer or seller.
     * @principle Restricts order access to buyer and seller.
     */
    match /orders/{orderId} {
      allow get: if isSignedIn() && (resource.data.buyerId == request.auth.uid || resource.data.sellerId == request.auth.uid);
      allow list: if false;
      allow create: if isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid);
      allow update: if isSignedIn() && isExistingOwner(resource.data.buyerId) || isExistingOwner(resource.data.sellerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.buyerId) || isExistingOwner(resource.data.sellerId);
    }

    /**
     * @description Security rules for payments.
     * @path /payments/{paymentId}
     * @allow (read, create, update, delete) If the authenticated user is the seller associated with the payment.
     * @deny (read, create, update, delete) If the authenticated user is not the seller associated with the payment.
     * @principle Restricts payment access to the seller.
     */
    match /payments/{paymentId} {
      allow get: if isSignedIn() && resource.data.sellerId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.sellerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.sellerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.sellerId);
    }

    /**
     * @description Security rules for plans.
     * @path /plans/{planId}
     * @allow (get, list) Public read access.
     * @deny (create, update, delete) No one can modify plans through the client; should be managed via the Firebase Admin SDK only.
     * @principle Public read, admin-only writes.
     */
    match /plans/{planId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Security rules for calls.
     * @path /calls/{callId}
     * @allow (read, create, update, delete) If the authenticated user is either the caller or the agent in the call.
     * @deny (read, create, update, delete) If the authenticated user is not involved in the call.
     * @principle Restricts call data access to participants.
     */
    match /calls/{callId} {
      allow get: if isSignedIn() && (resource.data.callerId == request.auth.uid || resource.data.agentId == request.auth.uid);
      allow list: if false;
      allow create: if isSignedIn() && (request.resource.data.callerId == request.auth.uid || request.resource.data.agentId == request.auth.uid);
      allow update: if isSignedIn() && (isExistingOwner(resource.data.callerId) || isExistingOwner(resource.data.agentId));
      allow delete: if isSignedIn() && (isExistingOwner(resource.data.callerId) || isExistingOwner(resource.data.agentId));
    }

    /**
     * @description Security rules for transactions.
     * @path /transactions/{txId}
     * @allow (read, create, update, delete) If the authenticated user is the owner of the transaction.
     * @deny (read, create, update, delete) If the authenticated user is not the owner of the transaction.
     * @principle Restricts transaction data access to the owner.
     */
    match /transactions/{txId} {
      allow get: if isSignedIn() && resource.data.uid == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.uid == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.uid);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.uid);
    }

    /**
     * @description Security rules for admin settings.
     * @path /adminSettings/{settingId}
     * @allow (read) Only authenticated users.
     * @allow (write) Only the admin.
     * @principle Restricts admin settings access to administrators.
     */
    match /adminSettings/{settingId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Security rules for admin agents.
     * @path /adminAgents/{agentId}
     * @allow (read) Only authenticated users.
     * @allow (write) Only the admin.
     * @principle Restricts admin agent access to administrators.
     */
    match /adminAgents/{agentId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Security rules for product verification.
     * @path /productVerification/{id}
     * @allow (read) Only authenticated users.
     * @allow (write) Only the admin.
     * @principle Restricts product verification to the admin.
     */
    match /productVerification/{id} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Security rules for media reports.
     * @path /mediaReports/{id}
     * @allow (read, write) Only the admin.
     * @principle Restricts media reports access to administrators.
     */
    match /mediaReports/{id} {
      allow get: if isAdmin();
      allow list: if false;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Security rules for posts.
     * @path /posts/{postId}
     * @allow (read, list) Public read access.
     * @allow (create) If the authenticated user's ID matches the post's authorId.
     * @allow (update, delete) If the authenticated user's ID matches the post's authorId and the resource exists.
     * @deny (create) If the authenticated user's ID does not match the post's authorId.
     * @deny (update, delete) If the authenticated user's ID does not match the post's authorId or the resource does not exist.
     * @principle Public read, owner-only writes with ownership validation.
     */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }
  }
}