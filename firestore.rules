/**
 * @fileoverview Firestore Security Rules for AkiliPesa Marketplace & Smart Escrow.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure access to user data and enforces ownership for writes while allowing public reads where appropriate.
 * Authorization is based on user authentication and explicit ownership or role-based checks.
 *
 * Data Structure:
 * The database contains a mix of user-owned data (under /users/{userId}),
 * publicly readable data (e.g., /posts, /products, /plans), and
 * transaction-related data (e.g., /orders, /escrow, /payments) that requires specific authorization logic.
 * Admin settings and agents are stored in dedicated top-level collections.
 *
 * Key Security Decisions:
 * - Strict user ownership is enforced for user profiles and related data.
 * - Public read access is granted to posts, products, and plans, but writes are restricted to owners.
 * - Transactional data (orders, escrow, payments) is secured using a combination of buyer/seller ownership and admin roles.
 * - Listing of user documents is generally allowed for the owner, except where explicitly restricted.
 * - Admin access is controlled via email verification.
 *
 * Denormalization for Authorization:
 *  - The rules assume that documents in the `orders` collection contain both `buyerId` and `sellerId` fields,
 *    allowing for direct authorization checks without additional `get()` calls.
 *
 * Structural Segregation:
 *  - Publicly readable data (e.g., posts, products) is stored in top-level collections, separate from private user data,
 *    to enable efficient and secure listing operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Protects user profiles. Only the user can read/write their own profile.
     * @path /users/{userId}
     * @allow (get, list, create, update, delete) if the user is the owner.
     * @deny (create, update, delete) if the user is not the owner.
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects user clones. Only the user can read/write their own clones.
     * @path /users/{userId}/clones/{cloneId}
     * @allow (get, list, create, update, delete) if the user is the owner.
     * @deny (create, update, delete) if the user is not the owner.
     * @principle Enforces user-ownership for clone data.
     */
    match /users/{userId}/clones/{cloneId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Protects user agents. Only the user can read/write their own agents.
     * @path /users/{userId}/agents/{agentId}
     * @allow (get, list, create, update, delete) if the user is the owner.
     * @deny (create, update, delete) if the user is not the owner.
     * @principle Enforces user-ownership for agent data.
     */
    match /users/{userId}/agents/{agentId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Allows public read access to posts, but restricts writes to the owner.
      * @path /posts/{postId}
      * @allow (get, list) public read access.
      * @allow (create) if request.auth.uid matches the authorId in the request.
      * @allow (update, delete) if the user is the owner of the post.
      * @deny (create, update, delete) if the user is not the owner.
      * @principle Grants public read access while enforcing ownership for writes.
      */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows public read access to products, but restricts writes to the owner.
     * @path /products/{productId}
     * @allow (get, list) public read access.
     * @allow (create) if request.auth.uid matches the ownerId in the request.
     * @allow (update, delete) if the user is the owner of the product.
     * @deny (create, update, delete) if the user is not the owner.
     * @principle Grants public read access while enforcing ownership for writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create: if request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Allows public read access to plans. Writes are not allowed from the client.
     * @path /plans/{planId}
     * @allow get, list: if true;
     * @deny create, update, delete: if true;
     * @principle Grants public read access to pricing plans.
     */
    match /plans/{planId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to order documents.
     * @path /orders/{orderId}
     * @allow (get, list, create) if the user is authenticated.
     * @allow (update) if the user is the buyer or seller associated with the order, and the document exists.
     * @deny (delete) to prevent unauthorized order deletion.
     * @principle Enforces authentication for basic access and restricts updates to order participants.
     */
    match /orders/{orderId} {
      allow get, list: if isSignedIn();
      allow create: if isSignedIn();
      allow update: if isSignedIn() && (resource != null) && (request.auth.uid == resource.data.sellerId || request.auth.uid == resource.data.buyerId);
      allow delete: if false;
    }

    /**
     * @description Controls access to escrow documents.
     * @path /escrow/{escrowId}
     * @allow (read) if the user is the buyer or seller or the admin.
     * @deny (create, update, delete) to prevent unauthorized escrow modifications.
     * @principle Restricts escrow access to relevant parties.
     */
    match /escrow/{escrowId} {
      allow get, list: if isSignedIn() && (resource.data.sellerId == request.auth.uid || resource.data.buyerId == request.auth.uid || request.auth.token.email == "blagridigital@gmail.com");
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows create access to deliveryProofs for buyers and sellers
     * @path /deliveryProofs/{id}
     * @allow create if request.auth.uid is either the buyer or the seller.
     */
    match /deliveryProofs/{id} {
      allow get, list: if isSignedIn() && (resource.data.sellerId == request.auth.uid || resource.data.buyerId == request.auth.uid);
      allow create: if isSignedIn() && (request.resource.data.buyerId == request.auth.uid || request.resource.data.sellerId == request.auth.uid);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to payment documents.
     * @path /payments/{paymentId}
     * @deny (all) to prevent unauthorized payment modifications.
     * @principle Payment data modifications will be done via cloud functions.
     */
    match /payments/{paymentId} {
        allow get, list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Controls access to call documents.
     * @path /calls/{callId}
     * @deny (all) to prevent unauthorized call modifications.
     * @principle Call data modifications will be done via cloud functions.
     */
    match /calls/{callId} {
        allow get, list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Controls access to transaction documents.
     * @path /transactions/{txId}
     * @allow (read, create) to authenticated users.
     * @deny (update, delete) to prevent unauthorized transaction modifications.
     */
    match /transactions/{txId} {
        allow get, list: if isSignedIn();
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Controls access to admin settings.
     * @path /adminSettings/{settingId}
     * @deny (all) to prevent unauthorized setting modifications.
     * @principle Admin settings will be only modified by admin cloud functions.
     */
    match /adminSettings/{settingId} {
        allow get, list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

     /**
     * @description Controls access to admin agents.
     * @path /adminAgents/{agentId}
     * @deny (all) to prevent unauthorized agent modifications.
     * @principle Admin agent settings will be only modified by admin cloud functions.
     */
      match /adminAgents/{agentId} {
        allow get, list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }
    
     /**
     * @description Controls access to orderTracking documents.
     * @path /orderTracking/{id}
     * @deny (all) to prevent direct client access.
     * @principle Order tracking modifications will be done via cloud functions.
     */
      match /orderTracking/{id} {
        allow get, list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Controls access to refund documents.
     * @path /refunds/{id}
     * @deny (all) to prevent direct client access.
     * @principle Refund requests will be triggered by clients, but all modifications will be done via cloud functions.
     */
      match /refunds/{id} {
        allow get, list: if false;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
    }

  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner.
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  // Helper function to determine if the user is the existing owner.
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}